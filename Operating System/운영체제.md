# 운영체제

### 프로세스와 스레드 

프로세스는 메모리 상에서 실행중인 프로그램을 뜻하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위이다. 프로세스마다 최소 하나의 스레드를 보유하고 있으며 각각 별도의 주소 공간을 독립적으로 할당 받는다. 스레드는 stack만 따로 할당받고 나머지 영역(code, data, heap)을 스레드끼리 서로 공유한다.

요약하면, 프로세스는 고유 공간과 자원을 할당받아서 사용하고, 스레드는 다른 스레드와 공간과 자원을 공유하면서 사용하는 것이다.

**멀티 프로세스 대신 멀티 스레드 사용하는 이유**

프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능하다. 또한 프로세스 간의 통신보다 스레드 간의 통신 비용이 적어 작업들 간의 부담을 감소시킬 수 있다.

</br>
</br>

### 교착상태

> 교착상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태이다. 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제점이다.

상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적 통제권을 요구함

점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림

비선점 : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음

순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음

</br>
</br>

### 교착상태 해결방법

**교착상태 예방**

- 상호 배제 부정 : 상호 배제를 하지 않는 시스템으로 구축하는 것이다. 하지만 공유 자원을 동시에 접근할 수 있으므로 컴퓨터 시스템의 신뢰성이 하락한다는 단점이 있다.
- 비 선점 부정 : 선점을 인정하는 것으로 실행 중인 프로세스나 공유자원을 중단하거나 빼앗을 수 있게 하는 것이다.
- 점유와 대기 부정 : 각 프로세스는 한 번에 자신에게 필요한 모든 자원을 요구해야 하며, 이 요구가 만족되지 않으면 작업을 진행할 수 없다.
- 환형 대기 부정 : 모든 자원에 일련의 순서를 부여하고, 각 프로세스가 오름차순으로만 자원을 요청할 수 있게 하는 것이다. 하지만 작업에 필요한 자원은 훨씬 오래 전부터 자원을 할당받은 상태가 되어야 하므로 자원의 낭비가 있을 수 있다.

**교착상태 회피**

프로세스가 자원을 요구할 때 시스템이 안전 상태를 유지할 수 있는 프로세스의 자원 요구만을 할당하여 주는 방안으로 자원 분배를 교착상태가 발생하지 않는 범위 내에서 하는 방안이다.

**교착상태 발견**

컴퓨터의 중단 원인이 교착상태인지 아니면 다른 이유인지를 파악하는 것이다. 자원들과 프로세스들을 인접 행렬로 표현하여 파악하는 특징이 있다.

**교착상태 회복**

교착상태의 원인이 되는 프로세스를 종료시키는 것이다.

- 교착상태를 일으킨 모든 프로세스를 동시에 종료
- 교착상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료
  - 우선순위가 낮은 것 종료
  - 우선순위가 같은 경우 진행이 적은 것 종료

</br>
</br>

### 메모리 계층

| 레지스터   |
| ---------- |
| 캐시       |
| 메모리     |
| 하드디스크 |

</br>
</br>

### 메모리 할당 알고리즘

First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당

Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해서 공간을 찾음

Best fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당

</br>
</br>

### 페이지 교체 알고리즘

> 페이지 부재 발생 시 새로운 페이지를 할당해야 하는데, 이 때 현재 할당되어 있는 페이지 중 어떤 것을 교체할지 결정하는 방법이다.

FIFO (First In First Out) : 메모리에 먼저 올라온 페이지를 교체하는 알고리즘

OPT (Optimal) : 가장 오랫동안 사용하지 않을 페이지를 교체하는 알고리즘

LRU (Least Recently Used) : 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘

LFU (Least Frequently Used) : 참조 횟수가 가장 적은 페이지를 교체하는 알고리즘

MFU (Most Frequently User) : 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘

</br>
</br>

### 단편화

> 기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상을 의미한다. RAM에서 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태이다.

외부 단편화 : 중간중간에 생긴 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 것

내부 단편화 : 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 현상

</br>
</br>

### 가상 메모리

메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조하여 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법이다.

</br>
</br>

### 페이징

프로세스가 차지하는 물리적 메모리 공간이 비연속적이 되도록 허용하는 메모리 관리 기법이다. 즉 프로세스를 일정 크기인 페이지 단위로 잘라서 메모리에 적재하는 것이다. 페이징은 외부 단편화 문제를 해결할 수 있다.

</br>
</br>

### 세그먼테이션

사용자/프로그래머 관점의 메모리 관리 기법이다. 페이징 기법처럼 같은 크기의 페이지를 갖는 것과는 다르게 논리적 내용의 단위로 나누므로 미리 분할하는 것이 아니고, 메모리를 사용할 시점에 할당한다. 세그먼테이션은 페이징과 다르게 자르는 단위가 고정되어 있지 않고, 의미 있는 단위로 나누기 때문에 보호와 공유 측면에서는 이점이 있지만 있지만 외부 단편화가 발생할 수 있다는 단점이 있다. 

</br>
</br>

### 세마포어와 뮤텍스

**세마포어** : 멀티 프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법이다. 스레드들이 리소스에 접근하면 세마포어는 카운터가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우 다음 작업은 대기하게 된다.

**뮤텍스** : 상호배제, 제어되는 섹션에 하나의 스레드만 허용하기 때문에 해당 섹션에 접근하려는 다른 스레드들을 강제적으로 막음으로써 단독으로 실행할 수 있게 해주는 것이다.

- lock : 임계구역에 들어갈 권한을 얻음 (다른 프로세스/스레드의 진입을 막음)
- unlock : 임계구역을 모두 사용했음을 알림 (다른 프로세스/스레드의 진입을 허용)

</br>
</br>

### Context Switching

하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 방법이다.

</br>
</br>

### 사용자 레벨 스레드와 커널 레벨 스레드

**사용자 레벨 스레드** : 사용자가 스레드 관련 라이브러리로 구현하여 사용하는 스레드이다. 스레드와 관련된 모든 행위를 사용자 영역에서 하기 때문에, 커널은 스레드 교환에 개입하지 않는다. 사용자 수준 스레드 N개가 커널 수준 스레드 1개에 매핑된다.

- 장점 : Context Switching이 없어서 커널 스레드보다 오버헤드가 적다.
- 단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지된다.

**커널 레벨 스레드** : 가장 가벼운 커널 스케줄링 단위이다. 하나의 프로세스는 적어도 하나의 커널 스레드를 가지게 되고, 커널 레벨스레드는 커널에 종속적이다. 커널이 각 스레드들을 개별적으로 관리할 수 있으므로, 동일한 프로세스에서 할당된 여러 개의 스레드들 중 한 스레드가 대기상태가 되더라도, 다른 스레드들은 실행시킬 수 있다.

- 장점 : 사용자 수준 스레드보다 효율적이다. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다.
- 단점 : Context Switching이 발생한다. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐수록 성능이 떨어지게 된다.

</br>
</br>

### fork()와 vfork()

**fork()** : 부모 프로세스의 메모리를 복사해서 사용한다.

**vfork()** : 부모 프로세스와의 메모리를 공유한다. 복사하지 않기 때문에 생성 속도가 빠르지만 자원을 공유하기 때문에 부모 프로세스는 자식 프로세스가 exit하거나 execute가 호출되기 전까지는 block된다.

</br>
</br>

### Race Condition

두 개 이상의 프로세스가 하나의 자원에 접근하기 위해 경쟁하는 상태를 말한다.

**해결방법**

- Mutual Exclusion (상호 배제) : 어떤 프로세스가 임계 영역을 수행 중이면 다른 프로세스들은 그 임계 영역에 들어가지 못하게 막는다.
- Progress (진행) : 임계 영역에 들어간 프로세스가 있지 않은 상태에서 임계 영역에 들어가려는 프로세스가 있으면 들어가게 해주는 것이다.
- Bounded Waiting (한정 대기) : 기아 상태를 방지하기 위해 프로세스가 임계 영역에 들어가려고 요청한 후부터 다른 프로세스들이 임계 영역에 들어가는 횟수에 한계가 있어야 한다. 임계 영역에 한번 들어갔다 나온 프로세스는 다음에 들어갈 때 제한을 둔다.





